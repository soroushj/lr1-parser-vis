{"mappings":"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","sources":["src/scripts/Lr1ParserVis.js","src/scripts/index.js"],"sourcesContent":["'use strict';\r\n\r\nexport default function (document) {\r\n\r\n  // Private fields\r\n\r\n  const _startSymbol = 0;\r\n  let _symbols;\r\n  let _symbolsTerminalOffset;\r\n  let _endMarker;\r\n  let _rules;\r\n  let _collection;\r\n  let _parseTable;\r\n  let _parseTableHasConflict;\r\n  let _parseSteps;\r\n\r\n  // Private functions for parsing\r\n  \r\n  const top = stack => (\r\n    stack[stack.length - 1]\r\n  );\r\n\r\n  const itemsEqual = (i1, i2) => (\r\n    i1.rule === i2.rule && i1.position === i2.position && i1.lookahead === i2.lookahead\r\n  );\r\n\r\n  const setsEqual = (s1, s2) => {\r\n    if (s1.length !== s2.length) {\r\n      return false;\r\n    }\r\n    let v = [];\r\n    for (let state = 0; state < s1.length; ++state) {\r\n      for (let j = 0; j < s1.length; ++j) {\r\n        if (!v.includes(j) && itemsEqual(s1[state], s2[j])) {\r\n          v.push(j);\r\n        }\r\n      }\r\n    }\r\n    return v.length === s1.length;\r\n  };\r\n\r\n  const actionsEqual = (a1, a2) => {\r\n    if (a1.type !== a2.type) {\r\n      return false;\r\n    }\r\n    switch (a1.type) {\r\n      case 'accept':\r\n        return true;\r\n      case 'shift':\r\n        return a1.state === a2.state;\r\n      case 'reduce':\r\n        return a1.rule === a2.rule;\r\n      case 'conflict':\r\n        return false;\r\n    }\r\n  };\r\n\r\n  const isNonTerminal = symbol => (\r\n    symbol < _symbolsTerminalOffset && symbol > 0\r\n  );\r\n\r\n  const isTerminal = symbol => (\r\n    symbol >= _symbolsTerminalOffset && symbol < _symbols.length - 1\r\n  );\r\n\r\n  const isTerminalOrEndMarker = symbol => (\r\n    symbol >= _symbolsTerminalOffset && symbol < _symbols.length\r\n  );\r\n\r\n  const first = symbol => {\r\n    if (isTerminalOrEndMarker(symbol)) {\r\n      return [symbol];\r\n    }\r\n    let f = [];\r\n    for (let i = 0; i < _rules.length; ++i) {\r\n      if (_rules[i].lhs === symbol && _rules[i].rhs[0] !== symbol) {\r\n        let fn = first(_rules[i].rhs[0]);\r\n        for (let j = 0; j < fn.length; ++j) {\r\n          f.push(fn[j]);\r\n        }\r\n      }\r\n    }\r\n    return f;\r\n  };\r\n\r\n  const closure = set => {\r\n    let closureSet = set.slice(0);\r\n    let newItemAdded = true;\r\n    while (newItemAdded) {\r\n      newItemAdded = false;\r\n      for (let i = 0; i < closureSet.length; ++i) {\r\n        let symbol = closureSet[i].rule.rhs[closureSet[i].position];\r\n        for (let j = 0; j < _rules.length; ++j) {\r\n          if (_rules[j].lhs === symbol) {\r\n            let f = first(\r\n              closureSet[i].position + 1 < closureSet[i].rule.rhs.length ?\r\n              closureSet[i].rule.rhs[closureSet[i].position + 1] :\r\n              closureSet[i].lookahead);\r\n            for (let k = 0; k < f.length; ++k) {\r\n              let item = {\r\n                rule: _rules[j],\r\n                position: 0,\r\n                lookahead: f[k]\r\n              };\r\n              let newItem = true;\r\n              for (let m = 0; m < closureSet.length; ++m) {\r\n                if (itemsEqual(closureSet[m], item)) {\r\n                  newItem = false;\r\n                  break;\r\n                }\r\n              }\r\n              if (newItem) {\r\n                closureSet.push(item);\r\n                newItemAdded = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return closureSet;\r\n  };\r\n\r\n  const goTo = (set, symbol) => {\r\n    let gotoSet = [];\r\n    for (let i = 0; i < set.length; ++i) {\r\n      if (set[i].rule.rhs[set[i].position] === symbol) {\r\n        gotoSet.push({\r\n          rule: set[i].rule,\r\n          position: set[i].position + 1,\r\n          lookahead: set[i].lookahead\r\n        });\r\n      }\r\n    }\r\n    return closure(gotoSet);\r\n  };\r\n\r\n  const scan = input => {\r\n    let s = input.trim().split(/\\s+/);\r\n    let r = [];\r\n    for (let i = 0; i < s.length; ++i) {\r\n      let t = _symbols.indexOf(s[i]);\r\n      if (!isTerminal(t)) {\r\n        return false;\r\n      }\r\n      r.push(t);\r\n    }\r\n    r.push(_endMarker);\r\n    return r;\r\n  };\r\n\r\n  const addRuleToParseTree = (tree, rule) => {\r\n    if (tree.symbol === rule.lhs && tree.children.length === 0) {\r\n      for (let i = 0; i < rule.rhs.length; ++i) {\r\n        tree.children.push({\r\n          symbol: rule.rhs[i],\r\n          children: []\r\n        });\r\n      }\r\n      return true;\r\n    }\r\n    for (let i = tree.children.length - 1; i >= 0; --i) {\r\n      if (addRuleToParseTree(tree.children[i], rule)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const getParseTree = () => {\r\n    let tree;\r\n    for (let i = _parseSteps.length - 1; i >= 0; --i) {\r\n      if (_parseSteps[i].action.type === 'reduce') {\r\n        if (tree === undefined) {\r\n          tree = {\r\n            symbol: _parseSteps[i].action.rule.lhs,\r\n            children: []\r\n          };\r\n        }\r\n        addRuleToParseTree(tree, _parseSteps[i].action.rule);\r\n      }\r\n    }\r\n    return tree;\r\n  };\r\n\r\n  const createCollection = () => {\r\n    _collection = [\r\n      closure([{\r\n        rule: _rules[0],\r\n        position: 0,\r\n        lookahead: _endMarker\r\n      }])\r\n    ];\r\n    let newSetAdded = true;\r\n    while (newSetAdded) {\r\n      newSetAdded = false;\r\n      for (let i = 0; i < _collection.length; ++i) {\r\n        for (let symbol = 1; symbol < _symbols.length - 1; ++symbol) {\r\n          let set = goTo(_collection[i], symbol);\r\n          if (set.length !== 0) {\r\n            let newSet = true;\r\n            for (let j = 0; j < _collection.length; ++j) {\r\n              if (setsEqual(_collection[j], set)) {\r\n                newSet = false;\r\n                break;\r\n              }\r\n            }\r\n            if (newSet) {\r\n              _collection.push(set);\r\n              newSetAdded = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const addActionToParseTable = (state, symbol, action) => {\r\n    if (_parseTable[state][symbol] === undefined) {\r\n      _parseTable[state][symbol] = action;\r\n    } else if (_parseTable[state][symbol].type === 'conflict') {\r\n      let newAction = true;\r\n      for (let i = 0; i < _parseTable[state][symbol].actions.length; ++i) {\r\n        if (actionsEqual(_parseTable[state][symbol].actions[i], action)) {\r\n          newAction = false;\r\n          break;\r\n        }\r\n      }\r\n      if (newAction) {\r\n        _parseTable[state][symbol].actions.push(action);\r\n      }\r\n    } else if (!actionsEqual(_parseTable[state][symbol], action)) {\r\n      _parseTable[state][symbol] = {\r\n        type: 'conflict',\r\n        actions: [_parseTable[state][symbol], action]\r\n      };\r\n      _parseTableHasConflict = true;\r\n    }\r\n  };\r\n\r\n  const createParseTable = () => {\r\n    _parseTable = new Array(_collection.length);\r\n    _parseTableHasConflict = false;\r\n    for (let i = 0; i < _collection.length; ++i) {\r\n      _parseTable[i] = new Array(_symbols.length);\r\n      for (let j = 0; j < _collection[i].length; ++j) {\r\n        let symbol = _collection[i][j].rule.rhs[_collection[i][j].position];\r\n        if (isTerminal(symbol)) {\r\n          let gotoSet = goTo(_collection[i], symbol);\r\n          for (let k = 0; k < _collection.length; ++k) {\r\n            if (setsEqual(_collection[k], gotoSet)) {\r\n              addActionToParseTable(i, symbol, {\r\n                type: 'shift',\r\n                state: k\r\n              });\r\n            }\r\n          }\r\n        }\r\n        if (_collection[i][j].position === _collection[i][j].rule.rhs.length) {\r\n          if (_collection[i][j].rule.lhs !== _startSymbol) {\r\n            addActionToParseTable(i, _collection[i][j].lookahead, {\r\n              type: 'reduce',\r\n              rule: _collection[i][j].rule\r\n            });\r\n          } else if (_collection[i][j].lookahead === _endMarker) {\r\n            _parseTable[i][_endMarker] = { type: 'accept' };\r\n          }\r\n        }\r\n      }\r\n      for (let symbol = 1; symbol < _symbolsTerminalOffset; ++symbol) {\r\n        let gotoSet = goTo(_collection[i], symbol);\r\n        for (let k = 0; k < _collection.length; ++k) {\r\n          if (setsEqual(_collection[k], gotoSet)) {\r\n            _parseTable[i][symbol] = k;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Public API for parsing\r\n\r\n  this.createParser = grammarStr => {\r\n    _symbols = [];\r\n    let lines = grammarStr.trim().split(/[\\r\\n]+/);\r\n    let rulesSymbols = [];\r\n    for (let i = 0; i < lines.length; ++i) {\r\n      rulesSymbols[i] = lines[i].trim().split(/\\s+/);\r\n      if (!_symbols.includes(rulesSymbols[i][0])) {\r\n        _symbols.push(rulesSymbols[i][0]);\r\n      }\r\n    }\r\n    _symbolsTerminalOffset = _symbols.length;\r\n    for (let i = 0; i < rulesSymbols.length; ++i) {\r\n      for (let j = 0; j < rulesSymbols[i].length; ++j) {\r\n        if (!_symbols.includes(rulesSymbols[i][j])) {\r\n          _symbols.push(rulesSymbols[i][j]);\r\n        }\r\n      }\r\n    }\r\n    _endMarker = _symbols.length;\r\n    _symbols.push('$');\r\n    _rules = [];\r\n    for (let i = 0; i < rulesSymbols.length; ++i) {\r\n      _rules[i] = {\r\n        index: i,\r\n        rhs: []\r\n      };\r\n      for (let j = 0; j < rulesSymbols[i].length; ++j) {\r\n        if (j === 0) {\r\n          _rules[i].lhs = _symbols.indexOf(rulesSymbols[i][j]);\r\n        } else {\r\n          _rules[i].rhs.push(_symbols.indexOf(rulesSymbols[i][j]));\r\n        }\r\n      }\r\n    }\r\n    createCollection();\r\n    createParseTable();\r\n  };\r\n  \r\n  this.parse = inputStr => {\r\n    if (_parseTable === undefined) {\r\n      return;\r\n    }\r\n    _parseSteps = [];\r\n    if (_parseTableHasConflict) {\r\n      _parseSteps.push({\r\n        stateStack: [],\r\n        symbolStack: [],\r\n        input: [],\r\n        action: {\r\n          type: 'error',\r\n          error: 'conflict in parse table'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    let input = scan(inputStr);\r\n    if (input === false) {\r\n      _parseSteps.push({\r\n        stateStack: [],\r\n        symbolStack: [],\r\n        input: [],\r\n        action: {\r\n          type: 'error',\r\n          error: 'syntax error'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    let stateStack = [0];\r\n    let symbolStack = [];\r\n    while (true) {\r\n      let action = _parseTable[top(stateStack)][input[0]];\r\n      if (action === undefined) {\r\n        action = {\r\n          type: 'error',\r\n          error: 'parse error'\r\n        };\r\n      }\r\n      \r\n      _parseSteps.push({\r\n        stateStack: stateStack.slice(0),\r\n        symbolStack: symbolStack.slice(0),\r\n        input: input.slice(0),\r\n        action: action\r\n      });\r\n      switch (action.type) {\r\n        case 'shift':\r\n          symbolStack.push(input.shift());\r\n          stateStack.push(action.state);\r\n          break;\r\n        case 'reduce':\r\n          for (let i = 0; i < action.rule.rhs.length; ++i) {\r\n            symbolStack.pop();\r\n            stateStack.pop();\r\n          }\r\n          symbolStack.push(action.rule.lhs);\r\n          stateStack.push(_parseTable[top(stateStack)][action.rule.lhs]);\r\n          break;\r\n        case 'accept':\r\n        case 'error':\r\n          return;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.clear = () => {\r\n    _symbols =\r\n    _symbolsTerminalOffset =\r\n    _endMarker =\r\n    _rules =\r\n    _collection =\r\n    _parseTable =\r\n    _parseTableHasConflict =\r\n    _parseSteps =\r\n    undefined;\r\n  };\r\n\r\n  // Private functions for rendering\r\n\r\n  const actionStr = action => {\r\n    switch (action.type) {\r\n      case 'accept':\r\n        return 'acc';\r\n      case 'shift':\r\n        return 's' + action.state;\r\n      case 'reduce':\r\n        return 'r' + action.rule.index;\r\n      case 'error':\r\n        return 'error: ' + action.error;\r\n      case 'conflict':\r\n        let str = actionStr(action.actions[0]);\r\n        for (let state = 1; state < action.actions.length; ++state) {\r\n          str += ',' + actionStr(action.actions[state]);\r\n        }\r\n        return str;\r\n    }\r\n  };\r\n\r\n  const symbolClass = symbol => {\r\n    if (symbol === _startSymbol) {\r\n      return 'start-symbol';\r\n    }\r\n    if (symbol === _endMarker) {\r\n      return 'end-marker';\r\n    }\r\n    if (isNonTerminal(symbol)) {\r\n      return 'non-terminal';\r\n    }\r\n    if (isTerminal(symbol)) {\r\n      return 'terminal';\r\n    }\r\n  };\r\n\r\n  const arrowNode = () => (\r\n    document.createTextNode(' \\u2192 ')\r\n  );\r\n\r\n  const bulletNode = () => (\r\n    document.createTextNode('\\u2022')\r\n  );\r\n\r\n  const element = (tag, content, classes, attrs) => {\r\n    let node = document.createElement(tag);\r\n    let contentItems;\r\n    if (content === undefined) {\r\n      contentItems = [];\r\n    } else if (Array.isArray(content)) {\r\n      contentItems = content;\r\n    } else {\r\n      contentItems = [content];\r\n    }\r\n    contentItems.forEach(contentItem => {\r\n      if (typeof contentItem === 'object') {\r\n        node.appendChild(contentItem);\r\n      } else {\r\n        node.appendChild(document.createTextNode(contentItem));\r\n      }\r\n    });\r\n    if (classes !== undefined) {\r\n      if (Array.isArray(classes)) {\r\n        node.classList.add(...classes);\r\n      } else {\r\n        node.classList.add(classes);\r\n      }\r\n    }\r\n    if (attrs !== undefined) {\r\n      Object.keys(attrs).forEach(key => {\r\n        node[key] = attrs[key];\r\n      });\r\n    }\r\n    return node;\r\n  };\r\n\r\n  const symbolNode = (symbol, additionalClass) => {\r\n    let classes = [symbolClass(symbol)];\r\n    if (additionalClass !== undefined) {\r\n      classes.push(additionalClass);\r\n    }\r\n    return element('b', _symbols[symbol], classes);\r\n  };\r\n\r\n  const symbolsNodes = symbols => (\r\n    symbols.map(symbol => (\r\n      symbolNode(symbol)\r\n    ))\r\n  );\r\n\r\n  const ruleNodes = rule => [\r\n    symbolNode(rule.lhs),\r\n    arrowNode(),\r\n    ...symbolsNodes(rule.rhs)\r\n  ];\r\n\r\n  const itemNodes = item => {\r\n    let nodes = [\r\n      symbolNode(item.rule.lhs),\r\n      arrowNode()\r\n    ];\r\n    item.rule.rhs.forEach((rhsSymbol, i) => {\r\n      if (item.position === i) {\r\n        nodes.push(bulletNode());\r\n      }\r\n      nodes.push(symbolNode(rhsSymbol));\r\n    });\r\n    if (item.position === item.rule.rhs.length) {\r\n      nodes.push(bulletNode());\r\n    }\r\n    nodes.push(document.createTextNode(','));\r\n    nodes.push(symbolNode(item.lookahead, 'lookahead'));\r\n    return nodes;\r\n  };\r\n\r\n  const treeNode = tree => {\r\n    if (tree === undefined) {\r\n      return undefined;\r\n    }\r\n    let ulNode = document.createElement('ul');\r\n    let liNode = document.createElement('li');\r\n    liNode.classList.add(symbolClass(tree.symbol));\r\n    ulNode.appendChild(liNode);\r\n    let spanNode = document.createElement('span');\r\n    spanNode.appendChild(document.createTextNode(_symbols[tree.symbol]));\r\n    liNode.appendChild(spanNode);\r\n    tree.children.forEach(child => {\r\n      let node = treeNode(child);\r\n      if (node !== undefined) {\r\n        ulNode.appendChild(node);\r\n      }\r\n    });\r\n    return ulNode;\r\n  };\r\n\r\n  // Public API for rendering\r\n\r\n  this.renderGrammar = container => {\r\n    container.innerHTML = '';\r\n    if (_symbols === undefined) {\r\n      return;\r\n    }\r\n    let preNode = document.createElement('pre');\r\n    _rules.forEach((rule, i) => {\r\n      preNode.appendChild(element('i', i + ' '));\r\n      ruleNodes(rule).forEach(ruleNode => {\r\n        preNode.appendChild(ruleNode);\r\n      });\r\n      if (i !== _rules.length - 1) {\r\n        preNode.appendChild(document.createElement('br'));\r\n      }\r\n    });\r\n    container.appendChild(preNode);\r\n  };\r\n  \r\n  this.renderCollection = container => {\r\n    container.innerHTML = '';\r\n    if (_collection === undefined) {\r\n      return;\r\n    }\r\n    let preNode = document.createElement('pre');\r\n    _collection.forEach((set, setIndex) => {\r\n      set.forEach((item, itemIndex) => {\r\n        preNode.appendChild(element('i',\r\n          itemIndex === 0 ?\r\n          ['I', element('sub', setIndex), ' '] :\r\n          undefined\r\n        ));\r\n        itemNodes(item).forEach(itemNode => {\r\n          preNode.appendChild(itemNode);\r\n        });\r\n        if (itemIndex !== set.length - 1) {\r\n          preNode.appendChild(document.createElement('br'));\r\n        }\r\n      });\r\n      if (setIndex !== _collection.length - 1) {\r\n        preNode.appendChild(document.createElement('br'));\r\n        preNode.appendChild(document.createElement('br'));\r\n      }\r\n    });\r\n    container.appendChild(preNode);\r\n  };\r\n  \r\n  this.renderParseTable = container => {\r\n    container.innerHTML = '';\r\n    if (_parseTable === undefined) {\r\n      return;\r\n    }\r\n    let tableNode = document.createElement('table');\r\n    let theadNode = document.createElement('thead');\r\n    tableNode.appendChild(theadNode);\r\n    let theadTr1Node = document.createElement('tr');\r\n    theadNode.appendChild(theadTr1Node);\r\n    let theadTr2Node = document.createElement('tr');\r\n    theadNode.appendChild(theadTr2Node);\r\n    let tbodyNode = document.createElement('tbody');\r\n    tableNode.appendChild(tbodyNode);\r\n    theadTr1Node.appendChild(element('th', 'state', undefined, { rowSpan: 2 }));\r\n    theadTr1Node.appendChild(element('th', 'action', undefined, { colSpan: _symbols.length - _symbolsTerminalOffset }));\r\n    theadTr1Node.appendChild(element('th', 'goto', undefined, { colSpan: _symbolsTerminalOffset - 1 }));\r\n    for (let s = _symbolsTerminalOffset; s < _symbols.length; ++s) {\r\n      let classes = ['action'];\r\n      if (s === _endMarker) {\r\n        classes.push('end-marker');\r\n      }\r\n      theadTr2Node.appendChild(element('th', _symbols[s], classes));\r\n    }\r\n    for (let s = 1; s < _symbolsTerminalOffset; ++s) {\r\n      theadTr2Node.appendChild(element('th', _symbols[s], 'goto'));\r\n    }\r\n    for (let i = 0; i < _parseTable.length; ++i) {\r\n      let trNode = document.createElement('tr');\r\n      tbodyNode.appendChild(trNode);\r\n      trNode.appendChild(element('td', i));\r\n      for (let s = _symbolsTerminalOffset; s < _symbols.length; ++s) {\r\n        if (_parseTable[i][s] === undefined) {\r\n          trNode.appendChild(element('td', undefined, 'error'));\r\n        } else {\r\n          trNode.appendChild(element('td', actionStr(_parseTable[i][s]), _parseTable[i][s].type));\r\n        }\r\n      }\r\n      for (let s = 1; s < _symbolsTerminalOffset; ++s) {\r\n        trNode.appendChild(element('td', _parseTable[i][s]));\r\n      }\r\n    }\r\n    container.appendChild(tableNode);\r\n  };\r\n  \r\n  this.renderParseSteps = container => {\r\n    container.innerHTML = '';\r\n    if (_parseSteps === undefined) {\r\n      return;\r\n    }\r\n    let tableNode = document.createElement('table');\r\n    let theadNode = document.createElement('thead');\r\n    tableNode.appendChild(theadNode);\r\n    let theadTrNode = document.createElement('tr');\r\n    theadNode.appendChild(theadTrNode);\r\n    let tbodyNode = document.createElement('tbody');\r\n    tableNode.appendChild(tbodyNode);\r\n    theadTrNode.appendChild(element('th', 'state stack'));\r\n    theadTrNode.appendChild(element('th', 'symbol stack'));\r\n    theadTrNode.appendChild(element('th', 'input'));\r\n    theadTrNode.appendChild(element('th', 'action'));\r\n    theadTrNode.appendChild(element('th', 'output'));\r\n    _parseSteps.forEach(step => {\r\n      let trNode = document.createElement('tr');\r\n      tbodyNode.appendChild(trNode);\r\n      trNode.appendChild(element('td', document.createTextNode(step.stateStack.join(' '))));\r\n      trNode.appendChild(element('td', symbolsNodes(step.symbolStack)));\r\n      trNode.appendChild(element('td', symbolsNodes(step.input)));\r\n      trNode.appendChild(element('td', actionStr(step.action), step.action.type));\r\n      trNode.appendChild(element('td',\r\n        step.action.type === 'reduce' ?\r\n        ruleNodes(step.action.rule) :\r\n        undefined\r\n      ));\r\n    });\r\n    container.appendChild(tableNode);\r\n  };\r\n  \r\n  this.renderParseTree = container => {\r\n    container.innerHTML = '';\r\n    if (_parseSteps === undefined) {\r\n      return;\r\n    }\r\n    let ulNode = treeNode(getParseTree());\r\n    if (ulNode !== undefined) {\r\n      container.appendChild(ulNode);\r\n    }\r\n  };\r\n\r\n  // Public API for samples\r\n\r\n  this.sampleGrammar = () => (\r\n    \"S' G\\n\" +\r\n    'G E = E\\n' +\r\n    'G id\\n' +\r\n    'E E + T\\n' +\r\n    'E T\\n' +\r\n    'T T * id\\n' +\r\n    'T id'\r\n  );\r\n\r\n  this.sampleInput = () => (\r\n    'id = id + id * id'\r\n  );\r\n\r\n};\r\n","'use strict';\n\nimport 'normalize.css';\nimport '../styles/index.scss';\nimport Lr1ParserVis from './Lr1ParserVis';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  const lr1ParserVis = new Lr1ParserVis(document);\n\n  const grammarText = document.getElementById('grammar-text');\n  const inputText = document.getElementById('input-text');\n  const containers = {\n    grammar: document.getElementById('grammar-container'),\n    collection: document.getElementById('collection-container'),\n    parseTable: document.getElementById('parse-table-container'),\n    parseSteps: document.getElementById('parse-steps-container'),\n    parseTree: document.getElementById('parse-tree-container'),\n  };\n\n  const emptyContainers = () => {\n    Object.keys(containers).forEach(key => {\n      containers[key].innerHTML = '';\n    });\n  };\n\n  const createParser = () => {\n    emptyContainers();\n    lr1ParserVis.createParser(grammarText.value);\n    lr1ParserVis.renderGrammar(containers.grammar);\n    lr1ParserVis.renderCollection(containers.collection);\n    lr1ParserVis.renderParseTable(containers.parseTable);\n  };\n\n  const parse = () => {\n    lr1ParserVis.parse(inputText.value);\n    lr1ParserVis.renderParseSteps(containers.parseSteps);\n    lr1ParserVis.renderParseTree(containers.parseTree);\n  };\n\n  const showExample = () => {\n    grammarText.value = lr1ParserVis.sampleGrammar();\n    createParser();\n    inputText.value = lr1ParserVis.sampleInput();\n    parse();\n  };\n\n  const clear = () => {\n    grammarText.value = '';\n    inputText.value = '';\n    emptyContainers();\n    lr1ParserVis.clear();\n  };\n\n  document.getElementById('create-parser').addEventListener('click', createParser);\n  document.getElementById('parse').addEventListener('click', parse);\n  document.getElementById('show-example').addEventListener('click', showExample);\n  document.getElementById('clear').addEventListener('click', clear);\n\n});\n"],"names":["document","_symbols","_symbolsTerminalOffset","_endMarker","_rules","_collection","_parseTable","_parseTableHasConflict","_parseSteps","top","stack","length","itemsEqual","i1","i2","rule","position","lookahead","setsEqual","s1","s2","v","state","j","includes","push","actionsEqual","a1","a2","type","isTerminal","symbol","first","isTerminalOrEndMarker","f","i","lhs","rhs","fn","closure","set","closureSet","slice","newItemAdded","k","item","newItem","m","goTo","gotoSet","addRuleToParseTree","tree","children","addActionToParseTable","action","undefined","newAction","actions","this","createParser","grammarStr","lines","trim","split","rulesSymbols","index","indexOf","newSetAdded","newSet","createCollection","Array","createParseTable","parse","inputStr","stateStack","symbolStack","input","error","s","r","t","scan","shift","pop","clear","actionStr","str","symbolClass","isNonTerminal","arrowNode","createTextNode","bulletNode","element","tag","content","classes","attrs","contentItems","node","createElement","isArray","forEach","contentItem","appendChild","classList","add","Object","keys","key","symbolNode","additionalClass","symbolsNodes","symbols","map","ruleNodes","treeNode","ulNode","liNode","spanNode","child","renderGrammar","container","innerHTML","preNode","ruleNode","renderCollection","setIndex","itemIndex","nodes","rhsSymbol","itemNodes","itemNode","renderParseTable","tableNode","theadNode","theadTr1Node","theadTr2Node","tbodyNode","rowSpan","colSpan","trNode","renderParseSteps","theadTrNode","step","join","renderParseTree","getParseTree","sampleGrammar","sampleInput","addEventListener","lr1ParserVis","$6aa6a539d62107d1$export$2e2bcd8739ae039","grammarText","getElementById","inputText","containers","grammar","collection","parseTable","parseSteps","parseTree","emptyContainers","value"],"version":3,"file":"index.184de947.js.map"}