{"mappings":"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","sources":["<anon>","src/scripts/index.js","src/scripts/Lr1ParserVis.js"],"sourcesContent":["\n\n\"use strict\";\nfunction $6aa6a539d62107d1$export$2e2bcd8739ae039(document) {\n    // Private fields\n    const _startSymbol = 0;\n    let _symbols;\n    let _symbolsTerminalOffset;\n    let _endMarker;\n    let _rules;\n    let _collection;\n    let _parseTable;\n    let _parseTableHasConflict;\n    let _parseSteps;\n    // Private functions for parsing\n    const top = (stack)=>stack[stack.length - 1];\n    const itemsEqual = (i1, i2)=>i1.rule === i2.rule && i1.position === i2.position && i1.lookahead === i2.lookahead;\n    const setsEqual = (s1, s2)=>{\n        if (s1.length !== s2.length) return false;\n        let v = [];\n        for(let state = 0; state < s1.length; ++state){\n            for(let j = 0; j < s1.length; ++j)if (!v.includes(j) && itemsEqual(s1[state], s2[j])) v.push(j);\n        }\n        return v.length === s1.length;\n    };\n    const actionsEqual = (a1, a2)=>{\n        if (a1.type !== a2.type) return false;\n        switch(a1.type){\n            case \"accept\":\n                return true;\n            case \"shift\":\n                return a1.state === a2.state;\n            case \"reduce\":\n                return a1.rule === a2.rule;\n            case \"conflict\":\n                return false;\n        }\n    };\n    const isNonTerminal = (symbol)=>symbol < _symbolsTerminalOffset && symbol > 0;\n    const isTerminal = (symbol)=>symbol >= _symbolsTerminalOffset && symbol < _symbols.length - 1;\n    const isTerminalOrEndMarker = (symbol)=>symbol >= _symbolsTerminalOffset && symbol < _symbols.length;\n    const first = (symbol)=>{\n        if (isTerminalOrEndMarker(symbol)) return [\n            symbol\n        ];\n        let f = [];\n        for(let i = 0; i < _rules.length; ++i)if (_rules[i].lhs === symbol && _rules[i].rhs[0] !== symbol) {\n            let fn = first(_rules[i].rhs[0]);\n            for(let j = 0; j < fn.length; ++j)f.push(fn[j]);\n        }\n        return f;\n    };\n    const closure = (set)=>{\n        let closureSet = set.slice(0);\n        let newItemAdded = true;\n        while(newItemAdded){\n            newItemAdded = false;\n            for(let i = 0; i < closureSet.length; ++i){\n                let symbol = closureSet[i].rule.rhs[closureSet[i].position];\n                for(let j = 0; j < _rules.length; ++j)if (_rules[j].lhs === symbol) {\n                    let f = first(closureSet[i].position + 1 < closureSet[i].rule.rhs.length ? closureSet[i].rule.rhs[closureSet[i].position + 1] : closureSet[i].lookahead);\n                    for(let k = 0; k < f.length; ++k){\n                        let item = {\n                            rule: _rules[j],\n                            position: 0,\n                            lookahead: f[k]\n                        };\n                        let newItem = true;\n                        for(let m = 0; m < closureSet.length; ++m)if (itemsEqual(closureSet[m], item)) {\n                            newItem = false;\n                            break;\n                        }\n                        if (newItem) {\n                            closureSet.push(item);\n                            newItemAdded = true;\n                        }\n                    }\n                }\n            }\n        }\n        return closureSet;\n    };\n    const goTo = (set, symbol)=>{\n        let gotoSet = [];\n        for(let i = 0; i < set.length; ++i)if (set[i].rule.rhs[set[i].position] === symbol) gotoSet.push({\n            rule: set[i].rule,\n            position: set[i].position + 1,\n            lookahead: set[i].lookahead\n        });\n        return closure(gotoSet);\n    };\n    const scan = (input)=>{\n        let s = input.trim().split(/\\s+/);\n        let r = [];\n        for(let i = 0; i < s.length; ++i){\n            let t = _symbols.indexOf(s[i]);\n            if (!isTerminal(t)) return false;\n            r.push(t);\n        }\n        r.push(_endMarker);\n        return r;\n    };\n    const addRuleToParseTree = (tree, rule)=>{\n        if (tree.symbol === rule.lhs && tree.children.length === 0) {\n            for(let i = 0; i < rule.rhs.length; ++i)tree.children.push({\n                symbol: rule.rhs[i],\n                children: []\n            });\n            return true;\n        }\n        for(let i = tree.children.length - 1; i >= 0; --i){\n            if (addRuleToParseTree(tree.children[i], rule)) return true;\n        }\n        return false;\n    };\n    const getParseTree = ()=>{\n        let tree;\n        for(let i = _parseSteps.length - 1; i >= 0; --i)if (_parseSteps[i].action.type === \"reduce\") {\n            if (tree === undefined) tree = {\n                symbol: _parseSteps[i].action.rule.lhs,\n                children: []\n            };\n            addRuleToParseTree(tree, _parseSteps[i].action.rule);\n        }\n        return tree;\n    };\n    const createCollection = ()=>{\n        _collection = [\n            closure([\n                {\n                    rule: _rules[0],\n                    position: 0,\n                    lookahead: _endMarker\n                }\n            ])\n        ];\n        let newSetAdded = true;\n        while(newSetAdded){\n            newSetAdded = false;\n            for(let i = 0; i < _collection.length; ++i)for(let symbol = 1; symbol < _symbols.length - 1; ++symbol){\n                let set = goTo(_collection[i], symbol);\n                if (set.length !== 0) {\n                    let newSet = true;\n                    for(let j = 0; j < _collection.length; ++j)if (setsEqual(_collection[j], set)) {\n                        newSet = false;\n                        break;\n                    }\n                    if (newSet) {\n                        _collection.push(set);\n                        newSetAdded = true;\n                    }\n                }\n            }\n        }\n    };\n    const addActionToParseTable = (state, symbol, action)=>{\n        if (_parseTable[state][symbol] === undefined) _parseTable[state][symbol] = action;\n        else if (_parseTable[state][symbol].type === \"conflict\") {\n            let newAction = true;\n            for(let i = 0; i < _parseTable[state][symbol].actions.length; ++i)if (actionsEqual(_parseTable[state][symbol].actions[i], action)) {\n                newAction = false;\n                break;\n            }\n            if (newAction) _parseTable[state][symbol].actions.push(action);\n        } else if (!actionsEqual(_parseTable[state][symbol], action)) {\n            _parseTable[state][symbol] = {\n                type: \"conflict\",\n                actions: [\n                    _parseTable[state][symbol],\n                    action\n                ]\n            };\n            _parseTableHasConflict = true;\n        }\n    };\n    const createParseTable = ()=>{\n        _parseTable = new Array(_collection.length);\n        _parseTableHasConflict = false;\n        for(let i = 0; i < _collection.length; ++i){\n            _parseTable[i] = new Array(_symbols.length);\n            for(let j = 0; j < _collection[i].length; ++j){\n                let symbol = _collection[i][j].rule.rhs[_collection[i][j].position];\n                if (isTerminal(symbol)) {\n                    let gotoSet = goTo(_collection[i], symbol);\n                    for(let k = 0; k < _collection.length; ++k)if (setsEqual(_collection[k], gotoSet)) addActionToParseTable(i, symbol, {\n                        type: \"shift\",\n                        state: k\n                    });\n                }\n                if (_collection[i][j].position === _collection[i][j].rule.rhs.length) {\n                    if (_collection[i][j].rule.lhs !== _startSymbol) addActionToParseTable(i, _collection[i][j].lookahead, {\n                        type: \"reduce\",\n                        rule: _collection[i][j].rule\n                    });\n                    else if (_collection[i][j].lookahead === _endMarker) _parseTable[i][_endMarker] = {\n                        type: \"accept\"\n                    };\n                }\n            }\n            for(let symbol = 1; symbol < _symbolsTerminalOffset; ++symbol){\n                let gotoSet = goTo(_collection[i], symbol);\n                for(let k = 0; k < _collection.length; ++k)if (setsEqual(_collection[k], gotoSet)) _parseTable[i][symbol] = k;\n            }\n        }\n    };\n    // Public API for parsing\n    this.createParser = (grammarStr)=>{\n        _symbols = [];\n        let lines = grammarStr.trim().split(/[\\r\\n]+/);\n        let rulesSymbols = [];\n        for(let i = 0; i < lines.length; ++i){\n            rulesSymbols[i] = lines[i].trim().split(/\\s+/);\n            if (!_symbols.includes(rulesSymbols[i][0])) _symbols.push(rulesSymbols[i][0]);\n        }\n        _symbolsTerminalOffset = _symbols.length;\n        for(let i = 0; i < rulesSymbols.length; ++i){\n            for(let j = 0; j < rulesSymbols[i].length; ++j)if (!_symbols.includes(rulesSymbols[i][j])) _symbols.push(rulesSymbols[i][j]);\n        }\n        _endMarker = _symbols.length;\n        _symbols.push(\"$\");\n        _rules = [];\n        for(let i = 0; i < rulesSymbols.length; ++i){\n            _rules[i] = {\n                index: i,\n                rhs: []\n            };\n            for(let j = 0; j < rulesSymbols[i].length; ++j)if (j === 0) _rules[i].lhs = _symbols.indexOf(rulesSymbols[i][j]);\n            else _rules[i].rhs.push(_symbols.indexOf(rulesSymbols[i][j]));\n        }\n        createCollection();\n        createParseTable();\n    };\n    this.parse = (inputStr)=>{\n        if (_parseTable === undefined) return;\n        _parseSteps = [];\n        if (_parseTableHasConflict) {\n            _parseSteps.push({\n                stateStack: [],\n                symbolStack: [],\n                input: [],\n                action: {\n                    type: \"error\",\n                    error: \"conflict in parse table\"\n                }\n            });\n            return;\n        }\n        let input = scan(inputStr);\n        if (input === false) {\n            _parseSteps.push({\n                stateStack: [],\n                symbolStack: [],\n                input: [],\n                action: {\n                    type: \"error\",\n                    error: \"syntax error\"\n                }\n            });\n            return;\n        }\n        let stateStack = [\n            0\n        ];\n        let symbolStack = [];\n        while(true){\n            let action = _parseTable[top(stateStack)][input[0]];\n            if (action === undefined) action = {\n                type: \"error\",\n                error: \"parse error\"\n            };\n            _parseSteps.push({\n                stateStack: stateStack.slice(0),\n                symbolStack: symbolStack.slice(0),\n                input: input.slice(0),\n                action: action\n            });\n            switch(action.type){\n                case \"shift\":\n                    symbolStack.push(input.shift());\n                    stateStack.push(action.state);\n                    break;\n                case \"reduce\":\n                    for(let i = 0; i < action.rule.rhs.length; ++i){\n                        symbolStack.pop();\n                        stateStack.pop();\n                    }\n                    symbolStack.push(action.rule.lhs);\n                    stateStack.push(_parseTable[top(stateStack)][action.rule.lhs]);\n                    break;\n                case \"accept\":\n                case \"error\":\n                    return;\n            }\n        }\n    };\n    this.clear = ()=>{\n        _symbols = _symbolsTerminalOffset = _endMarker = _rules = _collection = _parseTable = _parseTableHasConflict = _parseSteps = undefined;\n    };\n    // Private functions for rendering\n    const actionStr = (action)=>{\n        switch(action.type){\n            case \"accept\":\n                return \"acc\";\n            case \"shift\":\n                return \"s\" + action.state;\n            case \"reduce\":\n                return \"r\" + action.rule.index;\n            case \"error\":\n                return \"error: \" + action.error;\n            case \"conflict\":\n                let str = actionStr(action.actions[0]);\n                for(let state = 1; state < action.actions.length; ++state)str += \",\" + actionStr(action.actions[state]);\n                return str;\n        }\n    };\n    const symbolClass = (symbol)=>{\n        if (symbol === _startSymbol) return \"start-symbol\";\n        if (symbol === _endMarker) return \"end-marker\";\n        if (isNonTerminal(symbol)) return \"non-terminal\";\n        if (isTerminal(symbol)) return \"terminal\";\n    };\n    const arrowNode = ()=>document.createTextNode(\" \\u2192 \");\n    const bulletNode = ()=>document.createTextNode(\"\\u2022\");\n    const element = (tag, content, classes, attrs)=>{\n        let node = document.createElement(tag);\n        let contentItems;\n        if (content === undefined) contentItems = [];\n        else if (Array.isArray(content)) contentItems = content;\n        else contentItems = [\n            content\n        ];\n        contentItems.forEach((contentItem)=>{\n            if (typeof contentItem === \"object\") node.appendChild(contentItem);\n            else node.appendChild(document.createTextNode(contentItem));\n        });\n        if (classes !== undefined) {\n            if (Array.isArray(classes)) node.classList.add(...classes);\n            else node.classList.add(classes);\n        }\n        if (attrs !== undefined) Object.keys(attrs).forEach((key)=>{\n            node[key] = attrs[key];\n        });\n        return node;\n    };\n    const symbolNode = (symbol, additionalClass)=>{\n        let classes = [\n            symbolClass(symbol)\n        ];\n        if (additionalClass !== undefined) classes.push(additionalClass);\n        return element(\"b\", _symbols[symbol], classes);\n    };\n    const symbolsNodes = (symbols)=>symbols.map((symbol)=>symbolNode(symbol));\n    const ruleNodes = (rule)=>[\n            symbolNode(rule.lhs),\n            arrowNode(),\n            ...symbolsNodes(rule.rhs)\n        ];\n    const itemNodes = (item)=>{\n        let nodes = [\n            symbolNode(item.rule.lhs),\n            arrowNode()\n        ];\n        item.rule.rhs.forEach((rhsSymbol, i)=>{\n            if (item.position === i) nodes.push(bulletNode());\n            nodes.push(symbolNode(rhsSymbol));\n        });\n        if (item.position === item.rule.rhs.length) nodes.push(bulletNode());\n        nodes.push(document.createTextNode(\",\"));\n        nodes.push(symbolNode(item.lookahead, \"lookahead\"));\n        return nodes;\n    };\n    const treeNode = (tree)=>{\n        if (tree === undefined) return undefined;\n        let ulNode = document.createElement(\"ul\");\n        let liNode = document.createElement(\"li\");\n        liNode.classList.add(symbolClass(tree.symbol));\n        ulNode.appendChild(liNode);\n        let spanNode = document.createElement(\"span\");\n        spanNode.appendChild(document.createTextNode(_symbols[tree.symbol]));\n        liNode.appendChild(spanNode);\n        tree.children.forEach((child)=>{\n            let node = treeNode(child);\n            if (node !== undefined) ulNode.appendChild(node);\n        });\n        return ulNode;\n    };\n    // Public API for rendering\n    this.renderGrammar = (container)=>{\n        container.innerHTML = \"\";\n        if (_symbols === undefined) return;\n        let preNode = document.createElement(\"pre\");\n        _rules.forEach((rule, i)=>{\n            preNode.appendChild(element(\"i\", i + \" \"));\n            ruleNodes(rule).forEach((ruleNode)=>{\n                preNode.appendChild(ruleNode);\n            });\n            if (i !== _rules.length - 1) preNode.appendChild(document.createElement(\"br\"));\n        });\n        container.appendChild(preNode);\n    };\n    this.renderCollection = (container)=>{\n        container.innerHTML = \"\";\n        if (_collection === undefined) return;\n        let preNode = document.createElement(\"pre\");\n        _collection.forEach((set, setIndex)=>{\n            set.forEach((item, itemIndex)=>{\n                preNode.appendChild(element(\"i\", itemIndex === 0 ? [\n                    \"I\",\n                    element(\"sub\", setIndex),\n                    \" \"\n                ] : undefined));\n                itemNodes(item).forEach((itemNode)=>{\n                    preNode.appendChild(itemNode);\n                });\n                if (itemIndex !== set.length - 1) preNode.appendChild(document.createElement(\"br\"));\n            });\n            if (setIndex !== _collection.length - 1) {\n                preNode.appendChild(document.createElement(\"br\"));\n                preNode.appendChild(document.createElement(\"br\"));\n            }\n        });\n        container.appendChild(preNode);\n    };\n    this.renderParseTable = (container)=>{\n        container.innerHTML = \"\";\n        if (_parseTable === undefined) return;\n        let tableNode = document.createElement(\"table\");\n        let theadNode = document.createElement(\"thead\");\n        tableNode.appendChild(theadNode);\n        let theadTr1Node = document.createElement(\"tr\");\n        theadNode.appendChild(theadTr1Node);\n        let theadTr2Node = document.createElement(\"tr\");\n        theadNode.appendChild(theadTr2Node);\n        let tbodyNode = document.createElement(\"tbody\");\n        tableNode.appendChild(tbodyNode);\n        theadTr1Node.appendChild(element(\"th\", \"state\", undefined, {\n            rowSpan: 2\n        }));\n        theadTr1Node.appendChild(element(\"th\", \"action\", undefined, {\n            colSpan: _symbols.length - _symbolsTerminalOffset\n        }));\n        theadTr1Node.appendChild(element(\"th\", \"goto\", undefined, {\n            colSpan: _symbolsTerminalOffset - 1\n        }));\n        for(let s = _symbolsTerminalOffset; s < _symbols.length; ++s){\n            let classes = [\n                \"action\"\n            ];\n            if (s === _endMarker) classes.push(\"end-marker\");\n            theadTr2Node.appendChild(element(\"th\", _symbols[s], classes));\n        }\n        for(let s = 1; s < _symbolsTerminalOffset; ++s)theadTr2Node.appendChild(element(\"th\", _symbols[s], \"goto\"));\n        for(let i = 0; i < _parseTable.length; ++i){\n            let trNode = document.createElement(\"tr\");\n            tbodyNode.appendChild(trNode);\n            trNode.appendChild(element(\"td\", i));\n            for(let s = _symbolsTerminalOffset; s < _symbols.length; ++s)if (_parseTable[i][s] === undefined) trNode.appendChild(element(\"td\", undefined, \"error\"));\n            else trNode.appendChild(element(\"td\", actionStr(_parseTable[i][s]), _parseTable[i][s].type));\n            for(let s = 1; s < _symbolsTerminalOffset; ++s)trNode.appendChild(element(\"td\", _parseTable[i][s]));\n        }\n        container.appendChild(tableNode);\n    };\n    this.renderParseSteps = (container)=>{\n        container.innerHTML = \"\";\n        if (_parseSteps === undefined) return;\n        let tableNode = document.createElement(\"table\");\n        let theadNode = document.createElement(\"thead\");\n        tableNode.appendChild(theadNode);\n        let theadTrNode = document.createElement(\"tr\");\n        theadNode.appendChild(theadTrNode);\n        let tbodyNode = document.createElement(\"tbody\");\n        tableNode.appendChild(tbodyNode);\n        theadTrNode.appendChild(element(\"th\", \"state stack\"));\n        theadTrNode.appendChild(element(\"th\", \"symbol stack\"));\n        theadTrNode.appendChild(element(\"th\", \"input\"));\n        theadTrNode.appendChild(element(\"th\", \"action\"));\n        theadTrNode.appendChild(element(\"th\", \"output\"));\n        _parseSteps.forEach((step)=>{\n            let trNode = document.createElement(\"tr\");\n            tbodyNode.appendChild(trNode);\n            trNode.appendChild(element(\"td\", document.createTextNode(step.stateStack.join(\" \"))));\n            trNode.appendChild(element(\"td\", symbolsNodes(step.symbolStack)));\n            trNode.appendChild(element(\"td\", symbolsNodes(step.input)));\n            trNode.appendChild(element(\"td\", actionStr(step.action), step.action.type));\n            trNode.appendChild(element(\"td\", step.action.type === \"reduce\" ? ruleNodes(step.action.rule) : undefined));\n        });\n        container.appendChild(tableNode);\n    };\n    this.renderParseTree = (container)=>{\n        container.innerHTML = \"\";\n        if (_parseSteps === undefined) return;\n        let ulNode = treeNode(getParseTree());\n        if (ulNode !== undefined) container.appendChild(ulNode);\n    };\n    // Public API for samples\n    this.sampleGrammar = ()=>\"S' G\\nG E = E\\nG id\\nE E + T\\nE T\\nT T * id\\nT id\";\n    this.sampleInput = ()=>\"id = id + id * id\";\n}\n\n\n\"use strict\";\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    const lr1ParserVis = new (0, $6aa6a539d62107d1$export$2e2bcd8739ae039)(document);\n    const grammarText = document.getElementById(\"grammar-text\");\n    const inputText = document.getElementById(\"input-text\");\n    const containers = {\n        grammar: document.getElementById(\"grammar-container\"),\n        collection: document.getElementById(\"collection-container\"),\n        parseTable: document.getElementById(\"parse-table-container\"),\n        parseSteps: document.getElementById(\"parse-steps-container\"),\n        parseTree: document.getElementById(\"parse-tree-container\")\n    };\n    const emptyContainers = ()=>{\n        Object.keys(containers).forEach((key)=>{\n            containers[key].innerHTML = \"\";\n        });\n    };\n    const createParser = ()=>{\n        emptyContainers();\n        lr1ParserVis.createParser(grammarText.value);\n        lr1ParserVis.renderGrammar(containers.grammar);\n        lr1ParserVis.renderCollection(containers.collection);\n        lr1ParserVis.renderParseTable(containers.parseTable);\n    };\n    const parse = ()=>{\n        lr1ParserVis.parse(inputText.value);\n        lr1ParserVis.renderParseSteps(containers.parseSteps);\n        lr1ParserVis.renderParseTree(containers.parseTree);\n    };\n    const showExample = ()=>{\n        grammarText.value = lr1ParserVis.sampleGrammar();\n        createParser();\n        inputText.value = lr1ParserVis.sampleInput();\n        parse();\n    };\n    const clear = ()=>{\n        grammarText.value = \"\";\n        inputText.value = \"\";\n        emptyContainers();\n        lr1ParserVis.clear();\n    };\n    document.getElementById(\"create-parser\").addEventListener(\"click\", createParser);\n    document.getElementById(\"parse\").addEventListener(\"click\", parse);\n    document.getElementById(\"show-example\").addEventListener(\"click\", showExample);\n    document.getElementById(\"clear\").addEventListener(\"click\", clear);\n});\n\n\n//# sourceMappingURL=index.217f32d7.js.map\n","'use strict';\n\nimport 'normalize.css';\nimport '../styles/index.scss';\nimport Lr1ParserVis from './Lr1ParserVis';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  const lr1ParserVis = new Lr1ParserVis(document);\n\n  const grammarText = document.getElementById('grammar-text');\n  const inputText = document.getElementById('input-text');\n  const containers = {\n    grammar: document.getElementById('grammar-container'),\n    collection: document.getElementById('collection-container'),\n    parseTable: document.getElementById('parse-table-container'),\n    parseSteps: document.getElementById('parse-steps-container'),\n    parseTree: document.getElementById('parse-tree-container'),\n  };\n\n  const emptyContainers = () => {\n    Object.keys(containers).forEach(key => {\n      containers[key].innerHTML = '';\n    });\n  };\n\n  const createParser = () => {\n    emptyContainers();\n    lr1ParserVis.createParser(grammarText.value);\n    lr1ParserVis.renderGrammar(containers.grammar);\n    lr1ParserVis.renderCollection(containers.collection);\n    lr1ParserVis.renderParseTable(containers.parseTable);\n  };\n\n  const parse = () => {\n    lr1ParserVis.parse(inputText.value);\n    lr1ParserVis.renderParseSteps(containers.parseSteps);\n    lr1ParserVis.renderParseTree(containers.parseTree);\n  };\n\n  const showExample = () => {\n    grammarText.value = lr1ParserVis.sampleGrammar();\n    createParser();\n    inputText.value = lr1ParserVis.sampleInput();\n    parse();\n  };\n\n  const clear = () => {\n    grammarText.value = '';\n    inputText.value = '';\n    emptyContainers();\n    lr1ParserVis.clear();\n  };\n\n  document.getElementById('create-parser').addEventListener('click', createParser);\n  document.getElementById('parse').addEventListener('click', parse);\n  document.getElementById('show-example').addEventListener('click', showExample);\n  document.getElementById('clear').addEventListener('click', clear);\n\n});\n","'use strict';\r\n\r\nexport default function (document) {\r\n\r\n  // Private fields\r\n\r\n  const _startSymbol = 0;\r\n  let _symbols;\r\n  let _symbolsTerminalOffset;\r\n  let _endMarker;\r\n  let _rules;\r\n  let _collection;\r\n  let _parseTable;\r\n  let _parseTableHasConflict;\r\n  let _parseSteps;\r\n\r\n  // Private functions for parsing\r\n\r\n  const top = stack => (\r\n    stack[stack.length - 1]\r\n  );\r\n\r\n  const itemsEqual = (i1, i2) => (\r\n    i1.rule === i2.rule && i1.position === i2.position && i1.lookahead === i2.lookahead\r\n  );\r\n\r\n  const setsEqual = (s1, s2) => {\r\n    if (s1.length !== s2.length) {\r\n      return false;\r\n    }\r\n    let v = [];\r\n    for (let state = 0; state < s1.length; ++state) {\r\n      for (let j = 0; j < s1.length; ++j) {\r\n        if (!v.includes(j) && itemsEqual(s1[state], s2[j])) {\r\n          v.push(j);\r\n        }\r\n      }\r\n    }\r\n    return v.length === s1.length;\r\n  };\r\n\r\n  const actionsEqual = (a1, a2) => {\r\n    if (a1.type !== a2.type) {\r\n      return false;\r\n    }\r\n    switch (a1.type) {\r\n      case 'accept':\r\n        return true;\r\n      case 'shift':\r\n        return a1.state === a2.state;\r\n      case 'reduce':\r\n        return a1.rule === a2.rule;\r\n      case 'conflict':\r\n        return false;\r\n    }\r\n  };\r\n\r\n  const isNonTerminal = symbol => (\r\n    symbol < _symbolsTerminalOffset && symbol > 0\r\n  );\r\n\r\n  const isTerminal = symbol => (\r\n    symbol >= _symbolsTerminalOffset && symbol < _symbols.length - 1\r\n  );\r\n\r\n  const isTerminalOrEndMarker = symbol => (\r\n    symbol >= _symbolsTerminalOffset && symbol < _symbols.length\r\n  );\r\n\r\n  const first = symbol => {\r\n    if (isTerminalOrEndMarker(symbol)) {\r\n      return [symbol];\r\n    }\r\n    let f = [];\r\n    for (let i = 0; i < _rules.length; ++i) {\r\n      if (_rules[i].lhs === symbol && _rules[i].rhs[0] !== symbol) {\r\n        let fn = first(_rules[i].rhs[0]);\r\n        for (let j = 0; j < fn.length; ++j) {\r\n          f.push(fn[j]);\r\n        }\r\n      }\r\n    }\r\n    return f;\r\n  };\r\n\r\n  const closure = set => {\r\n    let closureSet = set.slice(0);\r\n    let newItemAdded = true;\r\n    while (newItemAdded) {\r\n      newItemAdded = false;\r\n      for (let i = 0; i < closureSet.length; ++i) {\r\n        let symbol = closureSet[i].rule.rhs[closureSet[i].position];\r\n        for (let j = 0; j < _rules.length; ++j) {\r\n          if (_rules[j].lhs === symbol) {\r\n            let f = first(\r\n              closureSet[i].position + 1 < closureSet[i].rule.rhs.length ?\r\n                closureSet[i].rule.rhs[closureSet[i].position + 1] :\r\n                closureSet[i].lookahead);\r\n            for (let k = 0; k < f.length; ++k) {\r\n              let item = {\r\n                rule: _rules[j],\r\n                position: 0,\r\n                lookahead: f[k]\r\n              };\r\n              let newItem = true;\r\n              for (let m = 0; m < closureSet.length; ++m) {\r\n                if (itemsEqual(closureSet[m], item)) {\r\n                  newItem = false;\r\n                  break;\r\n                }\r\n              }\r\n              if (newItem) {\r\n                closureSet.push(item);\r\n                newItemAdded = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return closureSet;\r\n  };\r\n\r\n  const goTo = (set, symbol) => {\r\n    let gotoSet = [];\r\n    for (let i = 0; i < set.length; ++i) {\r\n      if (set[i].rule.rhs[set[i].position] === symbol) {\r\n        gotoSet.push({\r\n          rule: set[i].rule,\r\n          position: set[i].position + 1,\r\n          lookahead: set[i].lookahead\r\n        });\r\n      }\r\n    }\r\n    return closure(gotoSet);\r\n  };\r\n\r\n  const scan = input => {\r\n    let s = input.trim().split(/\\s+/);\r\n    let r = [];\r\n    for (let i = 0; i < s.length; ++i) {\r\n      let t = _symbols.indexOf(s[i]);\r\n      if (!isTerminal(t)) {\r\n        return false;\r\n      }\r\n      r.push(t);\r\n    }\r\n    r.push(_endMarker);\r\n    return r;\r\n  };\r\n\r\n  const addRuleToParseTree = (tree, rule) => {\r\n    if (tree.symbol === rule.lhs && tree.children.length === 0) {\r\n      for (let i = 0; i < rule.rhs.length; ++i) {\r\n        tree.children.push({\r\n          symbol: rule.rhs[i],\r\n          children: []\r\n        });\r\n      }\r\n      return true;\r\n    }\r\n    for (let i = tree.children.length - 1; i >= 0; --i) {\r\n      if (addRuleToParseTree(tree.children[i], rule)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const getParseTree = () => {\r\n    let tree;\r\n    for (let i = _parseSteps.length - 1; i >= 0; --i) {\r\n      if (_parseSteps[i].action.type === 'reduce') {\r\n        if (tree === undefined) {\r\n          tree = {\r\n            symbol: _parseSteps[i].action.rule.lhs,\r\n            children: []\r\n          };\r\n        }\r\n        addRuleToParseTree(tree, _parseSteps[i].action.rule);\r\n      }\r\n    }\r\n    return tree;\r\n  };\r\n\r\n  const createCollection = () => {\r\n    _collection = [\r\n      closure([{\r\n        rule: _rules[0],\r\n        position: 0,\r\n        lookahead: _endMarker\r\n      }])\r\n    ];\r\n    let newSetAdded = true;\r\n    while (newSetAdded) {\r\n      newSetAdded = false;\r\n      for (let i = 0; i < _collection.length; ++i) {\r\n        for (let symbol = 1; symbol < _symbols.length - 1; ++symbol) {\r\n          let set = goTo(_collection[i], symbol);\r\n          if (set.length !== 0) {\r\n            let newSet = true;\r\n            for (let j = 0; j < _collection.length; ++j) {\r\n              if (setsEqual(_collection[j], set)) {\r\n                newSet = false;\r\n                break;\r\n              }\r\n            }\r\n            if (newSet) {\r\n              _collection.push(set);\r\n              newSetAdded = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const addActionToParseTable = (state, symbol, action) => {\r\n    if (_parseTable[state][symbol] === undefined) {\r\n      _parseTable[state][symbol] = action;\r\n    } else if (_parseTable[state][symbol].type === 'conflict') {\r\n      let newAction = true;\r\n      for (let i = 0; i < _parseTable[state][symbol].actions.length; ++i) {\r\n        if (actionsEqual(_parseTable[state][symbol].actions[i], action)) {\r\n          newAction = false;\r\n          break;\r\n        }\r\n      }\r\n      if (newAction) {\r\n        _parseTable[state][symbol].actions.push(action);\r\n      }\r\n    } else if (!actionsEqual(_parseTable[state][symbol], action)) {\r\n      _parseTable[state][symbol] = {\r\n        type: 'conflict',\r\n        actions: [_parseTable[state][symbol], action]\r\n      };\r\n      _parseTableHasConflict = true;\r\n    }\r\n  };\r\n\r\n  const createParseTable = () => {\r\n    _parseTable = new Array(_collection.length);\r\n    _parseTableHasConflict = false;\r\n    for (let i = 0; i < _collection.length; ++i) {\r\n      _parseTable[i] = new Array(_symbols.length);\r\n      for (let j = 0; j < _collection[i].length; ++j) {\r\n        let symbol = _collection[i][j].rule.rhs[_collection[i][j].position];\r\n        if (isTerminal(symbol)) {\r\n          let gotoSet = goTo(_collection[i], symbol);\r\n          for (let k = 0; k < _collection.length; ++k) {\r\n            if (setsEqual(_collection[k], gotoSet)) {\r\n              addActionToParseTable(i, symbol, {\r\n                type: 'shift',\r\n                state: k\r\n              });\r\n            }\r\n          }\r\n        }\r\n        if (_collection[i][j].position === _collection[i][j].rule.rhs.length) {\r\n          if (_collection[i][j].rule.lhs !== _startSymbol) {\r\n            addActionToParseTable(i, _collection[i][j].lookahead, {\r\n              type: 'reduce',\r\n              rule: _collection[i][j].rule\r\n            });\r\n          } else if (_collection[i][j].lookahead === _endMarker) {\r\n            _parseTable[i][_endMarker] = { type: 'accept' };\r\n          }\r\n        }\r\n      }\r\n      for (let symbol = 1; symbol < _symbolsTerminalOffset; ++symbol) {\r\n        let gotoSet = goTo(_collection[i], symbol);\r\n        for (let k = 0; k < _collection.length; ++k) {\r\n          if (setsEqual(_collection[k], gotoSet)) {\r\n            _parseTable[i][symbol] = k;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Public API for parsing\r\n\r\n  this.createParser = grammarStr => {\r\n    _symbols = [];\r\n    let lines = grammarStr.trim().split(/[\\r\\n]+/);\r\n    let rulesSymbols = [];\r\n    for (let i = 0; i < lines.length; ++i) {\r\n      rulesSymbols[i] = lines[i].trim().split(/\\s+/);\r\n      if (!_symbols.includes(rulesSymbols[i][0])) {\r\n        _symbols.push(rulesSymbols[i][0]);\r\n      }\r\n    }\r\n    _symbolsTerminalOffset = _symbols.length;\r\n    for (let i = 0; i < rulesSymbols.length; ++i) {\r\n      for (let j = 0; j < rulesSymbols[i].length; ++j) {\r\n        if (!_symbols.includes(rulesSymbols[i][j])) {\r\n          _symbols.push(rulesSymbols[i][j]);\r\n        }\r\n      }\r\n    }\r\n    _endMarker = _symbols.length;\r\n    _symbols.push('$');\r\n    _rules = [];\r\n    for (let i = 0; i < rulesSymbols.length; ++i) {\r\n      _rules[i] = {\r\n        index: i,\r\n        rhs: []\r\n      };\r\n      for (let j = 0; j < rulesSymbols[i].length; ++j) {\r\n        if (j === 0) {\r\n          _rules[i].lhs = _symbols.indexOf(rulesSymbols[i][j]);\r\n        } else {\r\n          _rules[i].rhs.push(_symbols.indexOf(rulesSymbols[i][j]));\r\n        }\r\n      }\r\n    }\r\n    createCollection();\r\n    createParseTable();\r\n  };\r\n\r\n  this.parse = inputStr => {\r\n    if (_parseTable === undefined) {\r\n      return;\r\n    }\r\n    _parseSteps = [];\r\n    if (_parseTableHasConflict) {\r\n      _parseSteps.push({\r\n        stateStack: [],\r\n        symbolStack: [],\r\n        input: [],\r\n        action: {\r\n          type: 'error',\r\n          error: 'conflict in parse table'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    let input = scan(inputStr);\r\n    if (input === false) {\r\n      _parseSteps.push({\r\n        stateStack: [],\r\n        symbolStack: [],\r\n        input: [],\r\n        action: {\r\n          type: 'error',\r\n          error: 'syntax error'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    let stateStack = [0];\r\n    let symbolStack = [];\r\n    while (true) {\r\n      let action = _parseTable[top(stateStack)][input[0]];\r\n      if (action === undefined) {\r\n        action = {\r\n          type: 'error',\r\n          error: 'parse error'\r\n        };\r\n      }\r\n\r\n      _parseSteps.push({\r\n        stateStack: stateStack.slice(0),\r\n        symbolStack: symbolStack.slice(0),\r\n        input: input.slice(0),\r\n        action: action\r\n      });\r\n      switch (action.type) {\r\n        case 'shift':\r\n          symbolStack.push(input.shift());\r\n          stateStack.push(action.state);\r\n          break;\r\n        case 'reduce':\r\n          for (let i = 0; i < action.rule.rhs.length; ++i) {\r\n            symbolStack.pop();\r\n            stateStack.pop();\r\n          }\r\n          symbolStack.push(action.rule.lhs);\r\n          stateStack.push(_parseTable[top(stateStack)][action.rule.lhs]);\r\n          break;\r\n        case 'accept':\r\n        case 'error':\r\n          return;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.clear = () => {\r\n    _symbols =\r\n      _symbolsTerminalOffset =\r\n      _endMarker =\r\n      _rules =\r\n      _collection =\r\n      _parseTable =\r\n      _parseTableHasConflict =\r\n      _parseSteps =\r\n      undefined;\r\n  };\r\n\r\n  // Private functions for rendering\r\n\r\n  const actionStr = action => {\r\n    switch (action.type) {\r\n      case 'accept':\r\n        return 'acc';\r\n      case 'shift':\r\n        return 's' + action.state;\r\n      case 'reduce':\r\n        return 'r' + action.rule.index;\r\n      case 'error':\r\n        return 'error: ' + action.error;\r\n      case 'conflict':\r\n        let str = actionStr(action.actions[0]);\r\n        for (let state = 1; state < action.actions.length; ++state) {\r\n          str += ',' + actionStr(action.actions[state]);\r\n        }\r\n        return str;\r\n    }\r\n  };\r\n\r\n  const symbolClass = symbol => {\r\n    if (symbol === _startSymbol) {\r\n      return 'start-symbol';\r\n    }\r\n    if (symbol === _endMarker) {\r\n      return 'end-marker';\r\n    }\r\n    if (isNonTerminal(symbol)) {\r\n      return 'non-terminal';\r\n    }\r\n    if (isTerminal(symbol)) {\r\n      return 'terminal';\r\n    }\r\n  };\r\n\r\n  const arrowNode = () => (\r\n    document.createTextNode(' \\u2192 ')\r\n  );\r\n\r\n  const bulletNode = () => (\r\n    document.createTextNode('\\u2022')\r\n  );\r\n\r\n  const element = (tag, content, classes, attrs) => {\r\n    let node = document.createElement(tag);\r\n    let contentItems;\r\n    if (content === undefined) {\r\n      contentItems = [];\r\n    } else if (Array.isArray(content)) {\r\n      contentItems = content;\r\n    } else {\r\n      contentItems = [content];\r\n    }\r\n    contentItems.forEach(contentItem => {\r\n      if (typeof contentItem === 'object') {\r\n        node.appendChild(contentItem);\r\n      } else {\r\n        node.appendChild(document.createTextNode(contentItem));\r\n      }\r\n    });\r\n    if (classes !== undefined) {\r\n      if (Array.isArray(classes)) {\r\n        node.classList.add(...classes);\r\n      } else {\r\n        node.classList.add(classes);\r\n      }\r\n    }\r\n    if (attrs !== undefined) {\r\n      Object.keys(attrs).forEach(key => {\r\n        node[key] = attrs[key];\r\n      });\r\n    }\r\n    return node;\r\n  };\r\n\r\n  const symbolNode = (symbol, additionalClass) => {\r\n    let classes = [symbolClass(symbol)];\r\n    if (additionalClass !== undefined) {\r\n      classes.push(additionalClass);\r\n    }\r\n    return element('b', _symbols[symbol], classes);\r\n  };\r\n\r\n  const symbolsNodes = symbols => (\r\n    symbols.map(symbol => (\r\n      symbolNode(symbol)\r\n    ))\r\n  );\r\n\r\n  const ruleNodes = rule => [\r\n    symbolNode(rule.lhs),\r\n    arrowNode(),\r\n    ...symbolsNodes(rule.rhs)\r\n  ];\r\n\r\n  const itemNodes = item => {\r\n    let nodes = [\r\n      symbolNode(item.rule.lhs),\r\n      arrowNode()\r\n    ];\r\n    item.rule.rhs.forEach((rhsSymbol, i) => {\r\n      if (item.position === i) {\r\n        nodes.push(bulletNode());\r\n      }\r\n      nodes.push(symbolNode(rhsSymbol));\r\n    });\r\n    if (item.position === item.rule.rhs.length) {\r\n      nodes.push(bulletNode());\r\n    }\r\n    nodes.push(document.createTextNode(','));\r\n    nodes.push(symbolNode(item.lookahead, 'lookahead'));\r\n    return nodes;\r\n  };\r\n\r\n  const treeNode = tree => {\r\n    if (tree === undefined) {\r\n      return undefined;\r\n    }\r\n    let ulNode = document.createElement('ul');\r\n    let liNode = document.createElement('li');\r\n    liNode.classList.add(symbolClass(tree.symbol));\r\n    ulNode.appendChild(liNode);\r\n    let spanNode = document.createElement('span');\r\n    spanNode.appendChild(document.createTextNode(_symbols[tree.symbol]));\r\n    liNode.appendChild(spanNode);\r\n    tree.children.forEach(child => {\r\n      let node = treeNode(child);\r\n      if (node !== undefined) {\r\n        ulNode.appendChild(node);\r\n      }\r\n    });\r\n    return ulNode;\r\n  };\r\n\r\n  // Public API for rendering\r\n\r\n  this.renderGrammar = container => {\r\n    container.innerHTML = '';\r\n    if (_symbols === undefined) {\r\n      return;\r\n    }\r\n    let preNode = document.createElement('pre');\r\n    _rules.forEach((rule, i) => {\r\n      preNode.appendChild(element('i', i + ' '));\r\n      ruleNodes(rule).forEach(ruleNode => {\r\n        preNode.appendChild(ruleNode);\r\n      });\r\n      if (i !== _rules.length - 1) {\r\n        preNode.appendChild(document.createElement('br'));\r\n      }\r\n    });\r\n    container.appendChild(preNode);\r\n  };\r\n\r\n  this.renderCollection = container => {\r\n    container.innerHTML = '';\r\n    if (_collection === undefined) {\r\n      return;\r\n    }\r\n    let preNode = document.createElement('pre');\r\n    _collection.forEach((set, setIndex) => {\r\n      set.forEach((item, itemIndex) => {\r\n        preNode.appendChild(element('i',\r\n          itemIndex === 0 ?\r\n            ['I', element('sub', setIndex), ' '] :\r\n            undefined\r\n        ));\r\n        itemNodes(item).forEach(itemNode => {\r\n          preNode.appendChild(itemNode);\r\n        });\r\n        if (itemIndex !== set.length - 1) {\r\n          preNode.appendChild(document.createElement('br'));\r\n        }\r\n      });\r\n      if (setIndex !== _collection.length - 1) {\r\n        preNode.appendChild(document.createElement('br'));\r\n        preNode.appendChild(document.createElement('br'));\r\n      }\r\n    });\r\n    container.appendChild(preNode);\r\n  };\r\n\r\n  this.renderParseTable = container => {\r\n    container.innerHTML = '';\r\n    if (_parseTable === undefined) {\r\n      return;\r\n    }\r\n    let tableNode = document.createElement('table');\r\n    let theadNode = document.createElement('thead');\r\n    tableNode.appendChild(theadNode);\r\n    let theadTr1Node = document.createElement('tr');\r\n    theadNode.appendChild(theadTr1Node);\r\n    let theadTr2Node = document.createElement('tr');\r\n    theadNode.appendChild(theadTr2Node);\r\n    let tbodyNode = document.createElement('tbody');\r\n    tableNode.appendChild(tbodyNode);\r\n    theadTr1Node.appendChild(element('th', 'state', undefined, { rowSpan: 2 }));\r\n    theadTr1Node.appendChild(element('th', 'action', undefined, { colSpan: _symbols.length - _symbolsTerminalOffset }));\r\n    theadTr1Node.appendChild(element('th', 'goto', undefined, { colSpan: _symbolsTerminalOffset - 1 }));\r\n    for (let s = _symbolsTerminalOffset; s < _symbols.length; ++s) {\r\n      let classes = ['action'];\r\n      if (s === _endMarker) {\r\n        classes.push('end-marker');\r\n      }\r\n      theadTr2Node.appendChild(element('th', _symbols[s], classes));\r\n    }\r\n    for (let s = 1; s < _symbolsTerminalOffset; ++s) {\r\n      theadTr2Node.appendChild(element('th', _symbols[s], 'goto'));\r\n    }\r\n    for (let i = 0; i < _parseTable.length; ++i) {\r\n      let trNode = document.createElement('tr');\r\n      tbodyNode.appendChild(trNode);\r\n      trNode.appendChild(element('td', i));\r\n      for (let s = _symbolsTerminalOffset; s < _symbols.length; ++s) {\r\n        if (_parseTable[i][s] === undefined) {\r\n          trNode.appendChild(element('td', undefined, 'error'));\r\n        } else {\r\n          trNode.appendChild(element('td', actionStr(_parseTable[i][s]), _parseTable[i][s].type));\r\n        }\r\n      }\r\n      for (let s = 1; s < _symbolsTerminalOffset; ++s) {\r\n        trNode.appendChild(element('td', _parseTable[i][s]));\r\n      }\r\n    }\r\n    container.appendChild(tableNode);\r\n  };\r\n\r\n  this.renderParseSteps = container => {\r\n    container.innerHTML = '';\r\n    if (_parseSteps === undefined) {\r\n      return;\r\n    }\r\n    let tableNode = document.createElement('table');\r\n    let theadNode = document.createElement('thead');\r\n    tableNode.appendChild(theadNode);\r\n    let theadTrNode = document.createElement('tr');\r\n    theadNode.appendChild(theadTrNode);\r\n    let tbodyNode = document.createElement('tbody');\r\n    tableNode.appendChild(tbodyNode);\r\n    theadTrNode.appendChild(element('th', 'state stack'));\r\n    theadTrNode.appendChild(element('th', 'symbol stack'));\r\n    theadTrNode.appendChild(element('th', 'input'));\r\n    theadTrNode.appendChild(element('th', 'action'));\r\n    theadTrNode.appendChild(element('th', 'output'));\r\n    _parseSteps.forEach(step => {\r\n      let trNode = document.createElement('tr');\r\n      tbodyNode.appendChild(trNode);\r\n      trNode.appendChild(element('td', document.createTextNode(step.stateStack.join(' '))));\r\n      trNode.appendChild(element('td', symbolsNodes(step.symbolStack)));\r\n      trNode.appendChild(element('td', symbolsNodes(step.input)));\r\n      trNode.appendChild(element('td', actionStr(step.action), step.action.type));\r\n      trNode.appendChild(element('td',\r\n        step.action.type === 'reduce' ?\r\n          ruleNodes(step.action.rule) :\r\n          undefined\r\n      ));\r\n    });\r\n    container.appendChild(tableNode);\r\n  };\r\n\r\n  this.renderParseTree = container => {\r\n    container.innerHTML = '';\r\n    if (_parseSteps === undefined) {\r\n      return;\r\n    }\r\n    let ulNode = treeNode(getParseTree());\r\n    if (ulNode !== undefined) {\r\n      container.appendChild(ulNode);\r\n    }\r\n  };\r\n\r\n  // Public API for samples\r\n\r\n  this.sampleGrammar = () => (\r\n    \"S' G\\n\" +\r\n    'G E = E\\n' +\r\n    'G id\\n' +\r\n    'E E + T\\n' +\r\n    'E T\\n' +\r\n    'T T * id\\n' +\r\n    'T id'\r\n  );\r\n\r\n  this.sampleInput = () => (\r\n    'id = id + id * id'\r\n  );\r\n\r\n};\r\n"],"names":["$6aa6a539d62107d1$export$2e2bcd8739ae039","document","_symbols","_symbolsTerminalOffset","_endMarker","_rules","_collection","_parseTable","_parseTableHasConflict","_parseSteps","top","stack","length","itemsEqual","i1","i2","rule","position","lookahead","setsEqual","s1","s2","v","state","j","includes","push","actionsEqual","a1","a2","type","isNonTerminal","symbol","isTerminal","isTerminalOrEndMarker","first","f","i","lhs","rhs","fn","closure","set","closureSet","slice","newItemAdded","k","item","newItem","m","goTo","gotoSet","scan","input","s","trim","split","r","t","indexOf","addRuleToParseTree","tree","children","getParseTree","action","undefined","createCollection","newSetAdded","newSet","addActionToParseTable","newAction","actions","createParseTable","Array","createParser","grammarStr","lines","rulesSymbols","index","parse","inputStr","stateStack","symbolStack","error","shift","pop","clear","actionStr","str","symbolClass","arrowNode","createTextNode","bulletNode","element","tag","content","classes","attrs","node","createElement","contentItems","isArray","forEach","contentItem","appendChild","classList","add","Object","keys","key","symbolNode","additionalClass","symbolsNodes","symbols","map","ruleNodes","itemNodes","nodes","rhsSymbol","treeNode","ulNode","liNode","spanNode","child","renderGrammar","container","innerHTML","preNode","ruleNode","renderCollection","setIndex","itemIndex","itemNode","renderParseTable","tableNode","theadNode","theadTr1Node","theadTr2Node","tbodyNode","rowSpan","colSpan","trNode","renderParseSteps","theadTrNode","step","join","renderParseTree","sampleGrammar","sampleInput","addEventListener","lr1ParserVis","grammarText","getElementById","inputText","containers","grammar","collection","parseTable","parseSteps","parseTree","emptyContainers","value"],"version":3,"file":"index.217f32d7.js.map"}